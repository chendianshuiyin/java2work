### mysql的扫描类型
All（全表扫描）；
index（全索引扫描）；
range（索引范围扫描）；
ref（非唯一索引扫描）；
eq_ref（唯一索引扫描）；
const（结果只有一条的主键或唯一索引扫描）。
执行效率依次从低到高

eq_ref多用于多表联合查询忠，const用于**主键**或唯一索引扫描与常量进行比较，效率更高。

### count函数的效率分析
count()是用来统计查询结果中函数指定的参数（字段或者整个记录）不为空的数量
因此效率`count(*)=count(1)>count(主键)>count(字段)`


### mysql的优化思路

**索引优化思路**

* 前缀索引优化，对记录的几个前缀建立索引，减少索引字段的大小，使一个索引页面能够容纳下更多的索引项

* 覆盖索引优化，使查询中的字段在二级索引中都能找得到，避免回表

* 主键索引最好自增，避免插入中间的键值引起页面的分裂
主键不应太大，否则其他的索引也会很大

* 优化查询语句，防止索引失效
索引最好设置为NOT NULL

**查询语句优化**
* 大数据量查询时limit优化，最好加上无序查询，这样可以避免数据库排序所耗费的时间

### 索引失效的原因
1.使用了左模糊查询或者左右模糊查询
**特殊情况**，使用`like "%xx"`扫描时，如果查询的字段在二级索引中已经全覆盖如`id，name`。则会进行name的全索引扫描（也是使用了索引），但效率比`ALL`扫描高。

2.对索引使用了函数
3.对索引使用了表达式运算
4.索引进行了隐式类型转换 （mysql会把字符串转为其他类型，当索引为字符串时相当于把索引强转为了其他类型，建立的索引就失效了）
5.联合索引进行了非最左匹配

6.使用了or或者in
使用`or`时前一个是有索引后一个无索引，就会导致走`ALL`扫描，改进方法是为后面一个也创建索引，这样分别用索引查找再合并。

### Myisam和innodb引擎的区别
1.innodb支持事务，而myisam不支持
2.innodb支持外键，而myisam不支持
3.innodb是聚簇索引，其主键索引和数据是放在一起的，二级索引里存放的是主键的值；而myisam是非聚簇索引，不论是主键索引还是二级索引，存放的都是数据文件的指针
3.innodb必须有唯一索引，而myisam可以没有
4.innodb不保存表的具体行数，执行select count时需要扫描全表，这是因为innodb支持事务，不同事物看到的表的行数是不一样的；而myisam有一个全局字段保存表的行数
5.innodb支持行级锁，而myisam仅支持表级锁
6.innodb不支持全文索引，myisam支持全文索引
### 数据库的四大特性
原子性：所有操作必须同时执行成功
数据一致性：事务操作前和操作后数据库里的数据满足完整性约束，保证一致
隔离性：多个事务可以并发的对数据库进行操作而不会相互制约
持久性：事务对数据库的改变是永久的

实现原理：原子性是通过undo log实现的，持久性是通过redo log实现的，隔离性是通过MVCC实现的，数据一致性是通过原子性+持久性+隔离性实现的

### 索引下推
对索引的判断在存储引擎完成，而不用在服务层完成

### 聚簇索引的特点
1.唯一性：一个表中只有一个聚簇索引
2.数据物理顺序：
3.主键默认：聚簇索引默认是主键，如果没有主键，会定义一个唯一且非空的索引作为聚簇索引，如果没有这样的索引，那么会自动创建一个索引
4.快速查询：聚簇索引中包含所有所有的数据，因此可以减少一次查询，（不用回表？）
5.范围查询优化：聚簇索引中，数据按顺序排在数据页上，相同值也排在一起，因此在进行范围查询比如group by 或者 order by的时候可以不用进行大范围查询
6.覆盖索引扫描

### 慢sql
当sql和索引都没有问题时的解决思路：
1.增加缓存，将一些热点数据放到redis里
2.分表
3.在读多写少的情况下可以采用主从复制
4.分库

如何保证redis里都是热点数据：利用redis的LRU算法，选择合适的LRU算法
allkeys-lru：从所有键中选择最近最少使用的键淘汰
volatile-lru：从设置了过期时间的所有键中选择最近最少使用的键淘汰

### mysql一张表能存储多少数据

取决于MySQL的配置和机器的硬件。

**内存充足时**：mysql会把索引装进内存，在innodb buffer size足够的情况下，能放得下全部索引，不会影响速度。
**内存不足时**：表的大小达到一个数量级后，内存无法存储索引，因此需要进行磁盘的io。此时一般最好**要求B+树的高度不要超过三层**，同时B+树的每个节点是一页16KB，这就限制了一个节点中的索引数量，从而限制了最终记录数量。一半来说大概在2000w左右（当然这与叶子节点记录的长度也有关）。

### sql如何分页，limit如何分页
分页使用limit实现，不同的页数根据关键字offset实现

### mysql的锁机制
从粒度大小分可以分为全局锁、表级锁和行级锁

而表级锁又可分为表锁、元数据锁、意向锁和AUTO-INC锁
表锁：可将整个表锁住，限制包括本进程在内的所有进程的读写，粒度较大，影响性能
元数据锁：自动加上的锁，进行CRUD操作时会加上MDL读锁，进行表结构改变的时候会加上MDL写锁，其中读锁和读锁之间不互斥，读锁写锁互斥并且写锁的优先级在读锁之上，当写锁阻塞时候，后续的读锁也会一起阻塞
意向锁：在对记录加上独占锁之前，需要先取得意向独占锁；在对记录加上共享锁之前，需要先取得意向共享锁。意向共享锁是用来快速判断表里是否有记录被加锁，如果没有意向锁，在给表加独占表锁时，需要遍历每一条记录，查看记录是否存在独占锁，而有了意向锁，只需要查看表里有无意向锁，这样就可以不用去遍历所有记录。
AUTO-INC锁：在插入数据时会加一个表级别的AUTO-INC锁，随后为被auto-increment修饰的字段自增1，在持有AUTO-INC锁的时候，其他事务的插入操作会被阻塞，从而保证了auto-increment修饰的字段能够正确递增。AUTO-INC锁是在语句执行完毕之后才释放的（ innodb_autoinc_lock_mode = 0），也可以设置参数 innodb_autoinc_lock_mode = 2来使申请自增后就释放锁，而不必等到语句执行完毕。但是这样存在的风险是可能使同一个会话的插入值主键不连续，从而使得主库从库不一致（从库只会执行完一个会话的插入后再执行另一个，此时是连续的），此时可以设置binlog日志的格式为row，从而使主从库的主键值一致

行级锁分为记录锁，间隙锁，和next-key锁，next-key是前两者的结合，它即锁住了一个区间，也锁住了一个点（左开右闭区间），还有插入意向锁。
插入意向锁与意向锁类似，如果记录插入位置已经被加了间隙锁，那么它会先阻塞，并在此期间生成一个插入意向锁（只是生成），并将锁设为等待状态，只有当前一个事务提交后，锁才会变为正常状态，值得注意**意向锁只是会提前生成，而不是生成之后就分配给事务。也就是说意向锁与间隙锁是互斥的，不可能一个事务持有间隙锁，一个事务持有意向锁，只有等持有间隙锁的事务提交之后，意向锁才会被分配到相应事务**
加行级锁的情况：使用锁定读
```
//对读取的记录加共享锁(S型锁)
select ... lock in share mode;

//对读取的记录加独占锁(X型锁)
select ... for update;
```
或者进行update和delete操作时会加上行级锁，加锁的基本单位是next-key锁，但是某些情况可能退化为间隙锁或者记录锁，这个要具体情况具体分析。
如果是对非唯一索引加锁，那么加锁之后能否插入二级索引值相同的记录，还要看其插入的范围，因为在锁定二级索引的同时也会锁定对应的主键。比如二级索引的间隙锁范围为（22，39），对应的主键值为10，20.那么能否插入二级索引为22，39的值得还需要看其主键的值，如果插入为（3，22）的值，那么可以插入成功，因为它不在间隙锁范围内，同理（12，22）就不能成功插入，因为它在间隙锁范围内
![](./static/二级索引表.png)
### mysql的五种数据类型
整型，浮点数类型，字符串类型，日期类型，二进制类型
### mysql进行范围查询时的过程
通过二分查找加载满足第一个叶子节点页到内存，在表中通过二分查找找到一一条满足要求的数据，之后通过页内链表和叶间链表不断查询，直到找到一条不满足要求的数据。
### 